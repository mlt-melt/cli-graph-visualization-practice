# Визуализация графа зависимостей — Этап 1

Минимальное CLI‑приложение, которое читает параметры из INI‑конфигурации, валидирует их и выводит в формате `ключ=значение`. Логика получения зависимостей на этом этапе отсутствует — фокус на конфигурировании и обработке ошибок.

## 1. Общее описание

Цель данного этапа — создать настраиваемое CLI‑приложение, которое:
- принимает путь к INI‑файлу конфигурации (`--config`),
- считывает параметры из секции `[app]`,
- валидирует значения с понятными сообщениями об ошибках,
- при успешной валидации печатает все параметры в формате `ключ=значение`.

Ограничения этапа: использование готовых средств для получения зависимостей (менеджеры пакетов, внешние библиотеки) запрещено. Вывод в виде дерева зависимостей пока не реализуется — только параметры.

## 2. Описание функций и настроек

Параметры конфигурации (INI, секция `[app]`):

- `package_name` — имя анализируемого пакета. Допустимые символы: латинские буквы, цифры, `.`, `_`, `-`. Должно начинаться с буквы/цифры. Длина: 1..128.
- `repo_source` — источник тестового репозитория:
  - если `test_repo_mode=local-path`, это должен быть существующий путь к файлу/директории;
  - если `test_repo_mode=remote-url`, это должен быть валидный URL со схемой `http`, `https` или `git`.
- `test_repo_mode` — режим работы с тестовым репозиторием: одно из `local-path`, `remote-url`.
- `output_mode` — режим вывода: одно из `ascii-tree`, `list` (на данном этапе влияет только на валидацию и отображение параметра).

Пример: см. `configs/config.example.ini`. Для запуска по умолчанию ожидается `./configs/config.ini`.

Обработка ошибок:
- Отсутствие файла конфигурации.
- Отсутствие секции `[app]` или обязательных ключей.
- Недопустимые значения параметров (несоответствие формату имени, несуществующий путь, неверный URL, недопустимый режим и т. п.).
- Сообщения агрегируются — выводится сразу список всех проблемных полей.

## 3. Команды для сборки проекта и запуска тестов

Сборка проекта не требуется (это обычный Python‑скрипт). Запуск осуществляется напрямую интерпретатором.

Запуск приложения (PowerShell):

```powershell
# Использовать конфиг по умолчанию ./configs/config.ini
python .\main.py

# Использовать конкретный файл конфигурации
python .\main.py --config .\configs\config.example.ini

# Этап 2: вывод прямых зависимостей (используется URL репозитория)
# Ограничение прототипа: поддерживается только GitHub URL вида https://github.com/<owner>/<repo>
python .\main.py --config .\configs\config.example.ini --action show-deps
```

Запуск тестов (если недоступен `pytest`, используем стандартный модуль `unittest`):

```powershell
# Явный поиск тестов в каталоге tests
python -m unittest discover -s tests -p "test_*.py" -v
```

## 4. Примеры использования

Успешный запуск с примером конфига (Этап 1):

```powershell
python .\main.py --config .\configs\config.example.ini
```

Пример вывода:

```
package_name=sample-package
repo_source=C:\\MyFiles\\python-projects\\EDU\\cli-graph-visualization-practice
test_repo_mode=local-path
output_mode=ascii-tree
```

Демонстрация ошибок валидации (намеренно неверный конфиг `configs/config.invalid.ini`):

```powershell
python .\main.py --config .\configs\config.invalid.ini
```

Возможный вывод ошибок:

```
Configuration validation failed:
 - package_name is invalid. Allowed: letters, numbers, '.', '_', '-'; must start with alnum; length 1..128.
 - test_repo_mode must be one of ['local-path', 'remote-url']; got 'remote'
 - output_mode must be one of ['ascii-tree', 'list']; got 'ascii'
 - repo_source is not a valid URL (test_repo_mode=remote-url): example
```

Пример вывода прямых зависимостей (Этап 2):

```powershell
python .\main.py --config .\configs\config.files.ini --action show-deps
```

Вывод (по одной зависимости в строке):

```
Newtonsoft.Json 13.0.1
Serilog 2.12.0
...
```

## Примечания

- На этом этапе приложение ничего не загружает из удалённых источников и не анализирует зависимости — только читает и валидирует конфигурацию.
- Этап 2 добавляет загрузку репозитория по URL (ограничение: GitHub), поиск `.nuspec`/`.csproj` и извлечение прямых зависимостей. Менеджеры пакетов и сторонние библиотеки не используются.
- На следующих этапах планируется визуализация зависимостей (например, ASCII‑дерево) и расширение поддерживаемых источников.
