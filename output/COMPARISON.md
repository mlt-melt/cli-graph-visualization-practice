# Сравнение с штатными инструментами визуализации NuGet

## Используемые инструменты

### Штатные инструменты .NET CLI:
- `dotnet list package` — отображает прямые зависимости
- `dotnet list package --include-transitive` — отображает все транзитивные зависимости

### Наш инструмент:
- Парсинг `.csproj`, `.nuspec`, `packages.config`
- Построение графа через итеративный DFS
- Визуализация через D2 и ASCII-дерево

## Пример сравнения

Для тестирования использован реальный проект: **Files** (https://github.com/files-community/Files)

### Наш инструмент
```powershell
python .\main.py --config .\configs\config.files.ini --action build-graph
```
Результат:
```
Nodes: 41
Edges: 40
No cycles detected
```

### Штатный инструмент .NET
Для корректного сравнения необходим клонированный репозиторий с .NET SDK:
```powershell
cd <path_to_cloned_Files_repo>
dotnet restore
dotnet list src/Files.App/Files.App.csproj package --include-transitive
```

## Возможные расхождения и их причины

### 1. Количество зависимостей
**Причина:** Наш инструмент строит граф от корневого пакета, включая только достижимые узлы. `dotnet list package --include-transitive` может показывать дополнительные зависимости, которые:
- Относятся к разным target frameworks (net6.0, net7.0, etc.)
- Являются build-time зависимостями (не runtime)
- Включены условно через MSBuild conditions

### 2. Версии пакетов
**Причина:** Наш инструмент показывает версии, указанные в `<PackageReference>`. Штатный инструмент показывает разрешенные (resolved) версии после применения:
- Version ranges (`[1.0,2.0)`)
- Floating versions (`1.0.*`)
- Centralized package management (Directory.Build.props)

### 3. Транзитивные зависимости
**Причина:** `dotnet list package --include-transitive` использует NuGet resolver, который:
- Загружает и анализирует .nuspec всех пакетов из удалённых источников
- Применяет правила разрешения конфликтов версий
- Учитывает RuntimeIdentifier (RID) для platform-specific dependencies

Наш инструмент:
- Парсит только локальные файлы проекта
- Не загружает зависимости второго уровня из NuGet.org
- Не применяет version resolution

### 4. Граф vs. Плоский список
**Штатный инструмент** выводит плоский список с указанием типа зависимости (Direct/Transitive).

**Наш инструмент** строит полный граф с информацией о связях между узлами, что позволяет:
- Визуализировать структуру зависимостей
- Обнаруживать циклы
- Находить обратные зависимости
- Анализировать пути зависимостей

## Выводы

### Сильные стороны нашего инструмента:
✅ Визуализация графа (D2 диаграммы и ASCII-дерево)  
✅ Обнаружение циклов  
✅ Поиск обратных зависимостей  
✅ Работа без установленного .NET SDK  
✅ Поддержка тестовых репозиториев для демонстрации  

### Ограничения:
❌ Не разрешает version ranges  
❌ Не загружает транзитивные зависимости из NuGet.org  
❌ Не учитывает условные зависимости (по target framework)  
❌ Не применяет NuGet dependency resolution алгоритмы  

### Рекомендации по использованию:
- Для **анализа структуры** зависимостей используйте наш инструмент
- Для **точного списка** установленных пакетов используйте `dotnet list package --include-transitive`
- Для **production builds** полагайтесь на официальный NuGet resolver

## Примечание
Расхождения в количестве зависимостей являются **ожидаемыми и нормальными**, так как наш инструмент:
1. Анализирует только прямые зависимости из файлов проекта
2. Не имитирует полный NuGet resolution process
3. Фокусируется на визуализации и анализе структуры, а не на точном воспроизведении build-time resolution

Это образовательный инструмент для понимания графов зависимостей, а не замена штатных инструментов NuGet.
